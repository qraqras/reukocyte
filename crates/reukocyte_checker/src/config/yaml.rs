//! YAML intermediate representation for .rubocop.yml parsing.
//!
//! This module defines the raw YAML structure that maps directly to RuboCop's
//! configuration format. The `define_cops!` macro generates the `RubocopYaml`
//! struct and related functionality.

use serde::Deserialize;
use std::path::PathBuf;

use super::macros::define_cops;

// ============================================================================
// Define all cops in one place
// ============================================================================
//
// To add a new cop:
// 1. Add it here: `"Category/CopName" => CopName, field_name`
// 2. Create the config module (e.g., `layout/new_cop.rs`)
// 3. Export it from `layout/mod.rs`
//
// That's it! RubocopYaml, from_rubocop_yaml, and merge_configs are auto-generated.

define_cops! {
    layout {
        "Layout/AccessModifierIndentation" => AccessModifierIndentation, access_modifier_indentation,
        "Layout/BeginEndAlignment" => BeginEndAlignment, begin_end_alignment,
        "Layout/DefEndAlignment" => DefEndAlignment, def_end_alignment,
        "Layout/EmptyLines" => EmptyLines, empty_lines,
        "Layout/EndAlignment" => EndAlignment, end_alignment,
        "Layout/IndentationConsistency" => IndentationConsistency, indentation_consistency,
        "Layout/IndentationStyle" => IndentationStyle, indentation_style,
        "Layout/IndentationWidth" => IndentationWidth, indentation_width,
        "Layout/LeadingEmptyLines" => LeadingEmptyLines, leading_empty_lines,
        "Layout/TrailingEmptyLines" => TrailingEmptyLines, trailing_empty_lines,
        "Layout/TrailingWhitespace" => TrailingWhitespace, trailing_whitespace,
    }
    lint {
        "Lint/Debugger" => Debugger, debugger,
    }
}

// ============================================================================
// InheritFrom enum (not generated by macro)
// ============================================================================

/// The `inherit_from` field can be a single string or a list of strings.
#[derive(Debug, Clone, Default, Deserialize)]
#[serde(untagged)]
pub enum InheritFrom {
    #[default]
    None,
    Single(String),
    Multiple(Vec<String>),
}
impl InheritFrom {
    /// Convert to a list of paths.
    pub fn to_paths(&self) -> Vec<PathBuf> {
        match self {
            InheritFrom::None => vec![],
            InheritFrom::Single(s) => vec![PathBuf::from(s)],
            InheritFrom::Multiple(v) => v.iter().map(PathBuf::from).collect(),
        }
    }
    /// Check if there are any inherited files.
    pub fn is_empty(&self) -> bool {
        match self {
            InheritFrom::None => true,
            InheritFrom::Single(_) => false,
            InheritFrom::Multiple(v) => v.is_empty(),
        }
    }
}

// ============================================================================
// AllCopsConfig (not generated by macro)
// ============================================================================

/// Global configuration that applies to all cops.
#[derive(Debug, Clone, Default, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct AllCopsConfig {
    /// Target Ruby version (e.g., "3.2", "3.3").
    #[serde(default)]
    pub target_ruby_version: Option<String>,
    /// Files to exclude from all cops.
    #[serde(default)]
    pub exclude: Vec<String>,
    /// Files to include for all cops.
    #[serde(default)]
    pub include: Vec<String>,
    /// Whether to use cache.
    #[serde(default)]
    pub use_cache: Option<bool>,
    /// Cache root directory.
    #[serde(default)]
    pub cache_root_directory: Option<String>,
    /// New cops behavior: enable, disable, or pending.
    #[serde(default)]
    pub new_cops: Option<String>,
    /// Suggested extensions.
    #[serde(default)]
    pub suggested_extensions: Option<bool>,
}

/// Merge AllCops configuration. Child values override parent values.
pub(super) fn merge_all_cops(parent: AllCopsConfig, child: AllCopsConfig) -> AllCopsConfig {
    AllCopsConfig {
        target_ruby_version: child.target_ruby_version.or(parent.target_ruby_version),
        exclude: if child.exclude.is_empty() { parent.exclude } else { child.exclude },
        include: if child.include.is_empty() { parent.include } else { child.include },
        use_cache: child.use_cache.or(parent.use_cache),
        cache_root_directory: child.cache_root_directory.or(parent.cache_root_directory),
        new_cops: child.new_cops.or(parent.new_cops),
        suggested_extensions: child.suggested_extensions.or(parent.suggested_extensions),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::layout::end_alignment::EnforcedStyleAlignWith;

    #[test]
    fn test_parse_simple_yaml() {
        let yaml = r#"
Layout/EndAlignment:
  Enabled: true
  EnforcedStyleAlignWith: variable
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        assert!(config.end_alignment.enabled);
        assert_eq!(config.end_alignment.enforced_style_align_with, EnforcedStyleAlignWith::Variable);
    }

    #[test]
    fn test_parse_inherit_from_single() {
        let yaml = r#"
inherit_from: .rubocop_todo.yml
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        let paths = config.inherit_from.to_paths();
        assert_eq!(paths.len(), 1);
        assert_eq!(paths[0], PathBuf::from(".rubocop_todo.yml"));
    }

    #[test]
    fn test_parse_inherit_from_multiple() {
        let yaml = r#"
inherit_from:
  - .rubocop_todo.yml
  - .rubocop_custom.yml
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        let paths = config.inherit_from.to_paths();
        assert_eq!(paths.len(), 2);
    }

    #[test]
    fn test_parse_all_cops() {
        let yaml = r#"
AllCops:
  TargetRubyVersion: 3.2
  NewCops: enable
  Exclude:
    - 'vendor/**/*'
    - 'db/schema.rb'
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(config.all_cops.target_ruby_version, Some("3.2".to_string()));
        assert_eq!(config.all_cops.new_cops, Some("enable".to_string()));
        assert_eq!(config.all_cops.exclude.len(), 2);
    }

    #[test]
    fn test_parse_enabled_false() {
        let yaml = r#"
Layout/EndAlignment:
  Enabled: false
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        assert!(!config.end_alignment.enabled);
    }

    #[test]
    fn test_parse_enabled_pending() {
        let yaml = r#"
Layout/EndAlignment:
  Enabled: pending
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        // "pending" is treated as enabled (not explicitly disabled)
        assert!(config.end_alignment.enabled);
    }
}
