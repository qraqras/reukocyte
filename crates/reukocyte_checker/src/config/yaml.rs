use super::macros::generate_rubocop_yaml;
use globset::Glob;
use globset::GlobSet;
use globset::GlobSetBuilder;
use serde::Deserialize;
use std::path::PathBuf;

// ============================================================================
// Define all cops in one place
// ============================================================================
//
// To add a new cop:
// 1. Add it here: `"Category/CopName" => CopName, field_name`
// 2. Create the config module (e.g., `layout/new_cop.rs`)
// 3. Export it from `layout/mod.rs`
//
// That's it! RubocopYaml, from_rubocop_yaml, and merge_configs are auto-generated.

generate_rubocop_yaml! {
    layout {
        "Layout/AccessModifierIndentation" => AccessModifierIndentation, access_modifier_indentation,
        "Layout/BeginEndAlignment" => BeginEndAlignment, begin_end_alignment,
        "Layout/DefEndAlignment" => DefEndAlignment, def_end_alignment,
        "Layout/EmptyLines" => EmptyLines, empty_lines,
        "Layout/EndAlignment" => EndAlignment, end_alignment,
        "Layout/IndentationConsistency" => IndentationConsistency, indentation_consistency,
        "Layout/IndentationStyle" => IndentationStyle, indentation_style,
        "Layout/IndentationWidth" => IndentationWidth, indentation_width,
        "Layout/LeadingEmptyLines" => LeadingEmptyLines, leading_empty_lines,
        "Layout/TrailingEmptyLines" => TrailingEmptyLines, trailing_empty_lines,
        "Layout/TrailingWhitespace" => TrailingWhitespace, trailing_whitespace,
    }
    lint {
        "Lint/Debugger" => Debugger, debugger,
    }
}

// ============================================================================
// InheritFrom enum (not generated by macro)
// ============================================================================

/// The `inherit_from` field can be a single string or a list of strings.
#[derive(Debug, Clone, Default, Deserialize)]
#[serde(untagged)]
pub enum InheritFrom {
    #[default]
    None,
    Single(String),
    Multiple(Vec<String>),
}
impl InheritFrom {
    /// Convert to a list of paths.
    pub fn to_paths(&self) -> Vec<PathBuf> {
        match self {
            InheritFrom::None => vec![],
            InheritFrom::Single(s) => vec![PathBuf::from(s)],
            InheritFrom::Multiple(v) => v.iter().map(PathBuf::from).collect(),
        }
    }
    /// Check if there are any inherited files.
    pub fn is_empty(&self) -> bool {
        match self {
            InheritFrom::None => true,
            InheritFrom::Single(_) => false,
            InheritFrom::Multiple(v) => v.is_empty(),
        }
    }
}

// ============================================================================
// AllCopsConfig (not generated by macro)
// ============================================================================

/// Global configuration that applies to all cops.
#[derive(Debug, Clone, Default, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub struct AllCopsConfig {
    #[serde(default)]
    pub target_ruby_version: Option<String>,
    #[serde(default)]
    pub exclude: Vec<String>,
    #[serde(default)]
    pub include: Vec<String>,
    #[serde(default)]
    pub use_cache: Option<bool>,
    #[serde(default)]
    pub cache_root_directory: Option<String>,
    #[serde(default)]
    pub new_cops: Option<String>,
    #[serde(default)]
    pub suggested_extensions: Option<bool>,
    #[serde(skip)]
    pub(crate) include_glob: Option<globset::GlobSet>,
    #[serde(skip)]
    pub(crate) exclude_glob: Option<globset::GlobSet>,
}
impl AllCopsConfig {
    /// Compile global include/exclude globs into GlobSets (idempotent).
    pub fn compile_globs(&mut self) {
        // helper to compile patterns
        fn compile(patterns: &Vec<String>) -> Option<GlobSet> {
            if patterns.is_empty() {
                None
            } else {
                let mut builder = GlobSetBuilder::new();
                for pattern in patterns {
                    if let Ok(g) = Glob::new(pattern) {
                        builder.add(g);
                    }
                }
                if let Ok(glob_set) = builder.build() { Some(glob_set) } else { None }
            }
        }
        // includes
        self.include_glob = if self.include.is_empty() { None } else { compile(&self.include) };
        // excludes
        self.exclude_glob = if self.exclude.is_empty() { None } else { compile(&self.exclude) };
    }
}

/// Merge AllCops configuration. Child values override parent values.
pub(super) fn merge_all_cops(parent: AllCopsConfig, child: AllCopsConfig) -> AllCopsConfig {
    AllCopsConfig {
        target_ruby_version: child.target_ruby_version.or(parent.target_ruby_version),
        exclude: if child.exclude.is_empty() { parent.exclude } else { child.exclude },
        include: if child.include.is_empty() { parent.include } else { child.include },
        use_cache: child.use_cache.or(parent.use_cache),
        cache_root_directory: child.cache_root_directory.or(parent.cache_root_directory),
        new_cops: child.new_cops.or(parent.new_cops),
        suggested_extensions: child.suggested_extensions.or(parent.suggested_extensions),
        include_glob: None,
        exclude_glob: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::layout::end_alignment::EnforcedStyleAlignWith;

    #[test]
    fn test_parse_simple_yaml() {
        let yaml = r#"
Layout/EndAlignment:
  Enabled: true
  EnforcedStyleAlignWith: variable
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        assert!(config.end_alignment.base.enabled);
        assert_eq!(config.end_alignment.enforced_style_align_with, EnforcedStyleAlignWith::Variable);
    }

    #[test]
    fn test_parse_inherit_from_single() {
        let yaml = r#"
inherit_from: .rubocop_todo.yml
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        let paths = config.inherit_from.to_paths();
        assert_eq!(paths.len(), 1);
        assert_eq!(paths[0], PathBuf::from(".rubocop_todo.yml"));
    }

    #[test]
    fn test_parse_inherit_from_multiple() {
        let yaml = r#"
inherit_from:
  - .rubocop_todo.yml
  - .rubocop_custom.yml
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        let paths = config.inherit_from.to_paths();
        assert_eq!(paths.len(), 2);
    }

    #[test]
    fn test_parse_all_cops() {
        let yaml = r#"
AllCops:
  TargetRubyVersion: 3.2
  NewCops: enable
  Exclude:
    - 'vendor/**/*'
    - 'db/schema.rb'
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(config.all_cops.target_ruby_version, Some("3.2".to_string()));
        assert_eq!(config.all_cops.new_cops, Some("enable".to_string()));
        assert_eq!(config.all_cops.exclude.len(), 2);
    }

    #[test]
    fn test_parse_enabled_false() {
        let yaml = r#"
Layout/EndAlignment:
  Enabled: false
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        assert!(!config.end_alignment.base.enabled);
    }

    #[test]
    fn test_parse_enabled_pending() {
        let yaml = r#"
Layout/EndAlignment:
  Enabled: pending
"#;
        let config: RubocopYaml = serde_yaml::from_str(yaml).unwrap();
        // "pending" is treated as enabled (not explicitly disabled)
        assert!(config.end_alignment.base.enabled);
    }

    #[test]
    fn test_compile_globs_populates_sets() {
        let mut cfg = AllCopsConfig::default();
        cfg.include = vec!["**/*.rb".to_string()];
        cfg.exclude = vec!["vendor/**/*".to_string()];
        cfg.compile_globs();
        assert!(cfg.include_glob.is_some());
        assert!(cfg.exclude_glob.is_some());
    }
}
